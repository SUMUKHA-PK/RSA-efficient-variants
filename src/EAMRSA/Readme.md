# The Encrypt Assistant Multi-Prime RSA

**Description of the algorithm:**  
1. Key generation: Input is a security parameter *n*, and three other parameters *b*, *k* and *c*. Private and Public keys are generated by the following steps:
    * Compute *b* distinct prime *p<sub>1</sub>,p<sub>2</sub>,....p<sub>b</sub>*, where each one is floor(n/b) bits in length and compute *N* = p<sub>1</sub>\*p<sub>2</sub>\*...\*p<sub>n</sub> . 
    * Compute *d* = (1/e)mod(\varphi (N)) where *\varphi* is *Eulers phi function* i.e \varphi(N) = (p<sub>1</sub>-1)\*(p<sub>2</sub>-1)\*....\*(p<sub>n</sub>-1) where *e* = 65537 and *e* and \phi (N) are relatively prime. 
    * Compute *r<sub>i</sub>* = d mod p<sub>i</sub> -1 and represent it as r<sub>i</sub> = d<sub>i,1</sub>\*e<sub>i,1</sub> + d<sub>i,2</sub>\*e<sub>i,2</sub> + .... + d<sub>i,k</sub>\*e<sub>i,k</sub>  where 1<=i<=b. *d<sub>i,j</sub> and e<sub>i,j</sub>* are random vector elements of c and |n| bits, respectively. 

    The public key is < N,e,e<sub>1,1</sub>, ... ,e<sub>1,k</sub>, ... ,e<sub>b,p</sub> ... ,e<sub>b,k</sub> > and the private key is < N, d<sub>1,p</sub> ... , d<sub>1,k</sub>' ... , d<sub>b,p</sub> ... , d<sub>b,k</sub> > .

2. Encryption: Following are the 2 steps involved
    * Given plaintext message M belongs to Z<sub>N</sub>, encrypt M as basic RSA. The ciphertext C is computed as C = M<sup>e</sup> mod N .
    * Compute vector Z = (z<sub>1,1</sub>,....z<sub>1,k</sub>,....,z<sub>b,1</sub>,...,z<sub>b,k</sub>) .Take C as input, where Z<sub>i,j</sub> = C<sup>e<sub>i,j</sub></sup> mod N , for 1 <= i <= b , 1 <= j <= k , and sends it to the decryption part.The ciphertext message is the vector Z.

3. Decryption: Decryption is done using the Chinese Remainder Theorem. Decrypt the vector Z and execute as the following steps:
    * Calculate Mi by the Mi = Z<sup>d<sub>i,1</sub></sup> (mod p<sub>1</sub>)\*Z<sup>d<sub>i,2</sub></sup> (mod p<sub>2</sub>) \*......\* Z<sup>d<sub>i,k</sub></sup> (mod p<sub>k</sub>) , for 1 <= i <= b, where p<sub>i</sub> has been computed.
    * According to the Chinese Remainder Theorem, Compute y<sub>i</sub> = N / p<sub>i</sub> = p<sub>1</sub>\*p<sub>2</sub>\* ... \*p<sub>i-1</sub>\*p<sub>i+1</sub>\* ...\* p<sub>b</sub> and <br> n<sub>i</sub> = y<sub>i</sub> \* (y<sub>i</sub><sup>-1</sup> (mod p<sub>i</sub> )) , for each i, 1 <= i <= b.
    * Using the CRT to combine the M<sub>i</sub> 's to obtain  M = C<sup>d</sup> = M<sub>1</sub> \* n<sub>1</sub> + ... + M<sub>i</sub> \* n<sub>i</sub> (mod N) , for each 1 <= i <= b.

**File structure:**

1. main.py : The main driver code 